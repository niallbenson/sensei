//! Note data model

use serde::{Deserialize, Serialize};

/// A note attached to book content
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Note {
    /// Unique identifier for the note
    pub id: String,
    /// Book this note belongs to
    pub book_id: String,
    /// Section path (e.g., "ch01/section02")
    pub section_path: String,
    /// Note content (markdown supported)
    pub content: String,
    /// Unix timestamp when created
    pub created_at: i64,
    /// Unix timestamp when last updated
    pub updated_at: i64,
    /// Where this note came from
    pub source: NoteSource,
    /// How the note is anchored to content
    pub anchor: NoteAnchor,
}

impl Note {
    /// Create a new section-level note
    pub fn new_section_note(book_id: &str, section_path: &str, content: &str) -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_or(0, |d| d.as_secs() as i64);

        Self {
            id: generate_id(),
            book_id: book_id.to_string(),
            section_path: section_path.to_string(),
            content: content.to_string(),
            created_at: now,
            updated_at: now,
            source: NoteSource::User,
            anchor: NoteAnchor::Section,
        }
    }

    /// Create a new text-selection note
    pub fn new_selection_note(
        book_id: &str,
        section_path: &str,
        content: &str,
        block_index: usize,
        start_char: usize,
        selected_text: &str,
    ) -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_or(0, |d| d.as_secs() as i64);

        Self {
            id: generate_id(),
            book_id: book_id.to_string(),
            section_path: section_path.to_string(),
            content: content.to_string(),
            created_at: now,
            updated_at: now,
            source: NoteSource::User,
            anchor: NoteAnchor::TextRange {
                block_index,
                start_char,
                char_length: selected_text.chars().count(),
                selected_text: selected_text.to_string(),
            },
        }
    }

    /// Update the note content
    pub fn update_content(&mut self, content: &str) {
        self.content = content.to_string();
        self.updated_at = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_or(0, |d| d.as_secs() as i64);
    }

    /// Check if this is a section-level note
    pub fn is_section_note(&self) -> bool {
        matches!(self.anchor, NoteAnchor::Section)
    }

    /// Check if this is a text-selection note
    pub fn is_selection_note(&self) -> bool {
        matches!(self.anchor, NoteAnchor::TextRange { .. })
    }
}

/// Where a note originated from
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum NoteSource {
    /// User-created note
    User,
    /// Generated by Claude Q&A
    Claude,
    /// Quiz explanation
    Quiz,
}

impl Default for NoteSource {
    fn default() -> Self {
        Self::User
    }
}

/// How a note is anchored to content
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum NoteAnchor {
    /// Section-level note (not tied to specific text)
    Section,
    /// Text-selection note with position info
    TextRange {
        /// Block index in section.content Vec<ContentBlock>
        block_index: usize,
        /// Character offset within the block's text
        start_char: usize,
        /// Length of the selection in characters
        char_length: usize,
        /// The selected text (for validation/display)
        selected_text: String,
    },
}

impl Default for NoteAnchor {
    fn default() -> Self {
        Self::Section
    }
}

impl NoteAnchor {
    /// Get the block index if this is a text range anchor
    pub fn block_index(&self) -> Option<usize> {
        match self {
            Self::Section => None,
            Self::TextRange { block_index, .. } => Some(*block_index),
        }
    }

    /// Get the character range if this is a text range anchor
    pub fn char_range(&self) -> Option<(usize, usize)> {
        match self {
            Self::Section => None,
            Self::TextRange { start_char, char_length, .. } => {
                Some((*start_char, *start_char + *char_length))
            }
        }
    }

    /// Get the selected text if this is a text range anchor
    pub fn selected_text(&self) -> Option<&str> {
        match self {
            Self::Section => None,
            Self::TextRange { selected_text, .. } => Some(selected_text),
        }
    }
}

/// Generate a unique ID for a note
fn generate_id() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH).map_or(0, |d| d.as_nanos());

    // Simple ID: timestamp + random suffix
    format!("note_{:x}_{:04x}", timestamp, rand_u16())
}

/// Simple random u16 without external dependencies
fn rand_u16() -> u16 {
    use std::collections::hash_map::RandomState;
    use std::hash::{BuildHasher, Hasher};

    let state = RandomState::new();
    let mut hasher = state.build_hasher();
    hasher.write_u64(
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_or(0, |d| d.as_nanos() as u64),
    );
    hasher.finish() as u16
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn create_section_note() {
        let note = Note::new_section_note("book1", "ch01/s01", "My note");
        assert_eq!(note.book_id, "book1");
        assert_eq!(note.section_path, "ch01/s01");
        assert_eq!(note.content, "My note");
        assert!(note.is_section_note());
        assert!(!note.is_selection_note());
        assert_eq!(note.source, NoteSource::User);
    }

    #[test]
    fn create_selection_note() {
        let note = Note::new_selection_note(
            "book1",
            "ch01/s01",
            "Note about this",
            2,
            10,
            "selected text",
        );
        assert!(note.is_selection_note());
        assert!(!note.is_section_note());

        if let NoteAnchor::TextRange { block_index, start_char, char_length, selected_text } =
            &note.anchor
        {
            assert_eq!(*block_index, 2);
            assert_eq!(*start_char, 10);
            assert_eq!(*char_length, 13); // "selected text" has 13 chars
            assert_eq!(selected_text, "selected text");
        } else {
            panic!("Expected TextRange anchor");
        }
    }

    #[test]
    fn update_note_content() {
        let mut note = Note::new_section_note("book1", "ch01/s01", "Original");
        let original_updated = note.updated_at;

        // Small delay to ensure timestamp changes
        std::thread::sleep(std::time::Duration::from_millis(10));

        note.update_content("Updated content");
        assert_eq!(note.content, "Updated content");
        assert!(note.updated_at >= original_updated);
    }

    #[test]
    fn anchor_methods() {
        let section = NoteAnchor::Section;
        assert!(section.block_index().is_none());
        assert!(section.char_range().is_none());
        assert!(section.selected_text().is_none());

        let range = NoteAnchor::TextRange {
            block_index: 5,
            start_char: 20,
            char_length: 10,
            selected_text: "hello".to_string(),
        };
        assert_eq!(range.block_index(), Some(5));
        assert_eq!(range.char_range(), Some((20, 30)));
        assert_eq!(range.selected_text(), Some("hello"));
    }

    #[test]
    fn note_id_is_unique() {
        let note1 = Note::new_section_note("book1", "ch01", "Note 1");
        let note2 = Note::new_section_note("book1", "ch01", "Note 2");
        assert_ne!(note1.id, note2.id);
    }

    #[test]
    fn note_source_default() {
        assert_eq!(NoteSource::default(), NoteSource::User);
    }

    #[test]
    fn note_anchor_default() {
        assert_eq!(NoteAnchor::default(), NoteAnchor::Section);
    }
}
